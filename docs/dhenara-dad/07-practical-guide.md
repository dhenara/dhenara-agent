# Dhenara Agent DSL (DAD) - Practical Guide

## Building Real-World Applications with DAD

This guide provides practical examples and best practices for building agent applications with DAD. We'll walk through common patterns, pitfalls to avoid, and techniques for successful implementation.

## Simple Agent Pattern

A common pattern for simple agents is a single flow with multiple processing steps:

```python
from dhenara.agent.dsl import (
    AIModelNode,
    AIModelNodeSettings,
    EventType,
    FileOperationNode,
    FileOperationNodeSettings,
    FlowDefinition,
    FolderAnalyzerNode,
    FolderAnalyzerSettings,
)
from dhenara.ai.types import ResourceConfigItem, Prompt

# Create a flow for a simple code assistant
code_assistant = FlowDefinition(root_id="code_assistant")

# Add a folder analysis node to understand the codebase
code_assistant.node(
    "repo_analyzer",
    FolderAnalyzerNode(
        pre_events=[EventType.node_input_required],
        settings=FolderAnalyzerSettings(
            base_directory="./",
            max_file_size=100000,  # 100KB
        ),
    ),
)

# Add an AI model node to generate code
code_assistant.node(
    "code_generator",
    AIModelNode(
        resources=ResourceConfigItem.with_model("claude-3-5-sonnet"),
        settings=AIModelNodeSettings(
            system_instructions=[
                "You are a code assistant that generates high-quality Python code.",
                "Focus on writing clean, maintainable, and efficient code.",
            ],
            prompt=Prompt.with_dad_text(
                "Based on the following code repository structure and user request, generate appropriate code:\n\n"
                "Repository:\n$var{repo_analysis}\n\n"
                "User Request:\n$var{user_request}"
            ),
        ),
    ),
)

# Add a file operation node to save the generated code
code_assistant.node(
    "file_writer",
    FileOperationNode(
        settings=FileOperationNodeSettings(
            base_directory="./",
            stage=True,
            commit=True,
            commit_message="Code generated by assistant",
        ),
    ),
)
```

## Setup and Execution Code

To run the agent, you need setup and execution code:

```python
from dhenara.agent.runner import FlowRunner
from dhenara.agent.run import RunContext, IsolatedExecution
from pathlib import Path
import asyncio

async def run_agent(user_request: str):
    # Create run context
    run_context = RunContext(
        root_component_id="code_assistant",
        project_root=Path("."),
    )
    
    # Setup the run
    run_context.setup_run()
    
    # Register input handler for folder analyzer
    async def folder_analyzer_input_handler(event):
        if event.node_id == "repo_analyzer":
            from dhenara.agent.dsl.inbuilt.flow_nodes.defs.types import FolderAnalyzerNodeInput, FolderAnalysisOperation
            
            event.input = FolderAnalyzerNodeInput(
                settings_override=FolderAnalyzerSettings(
                    operations=[
                        FolderAnalysisOperation(
                            operation_type="analyze_folder",
                            path="src",
                            recursive=True,
                            exclude_patterns=["*.pyc", "__pycache__", ".git"],
                        )
                    ]
                )
            )
            event.handled = True
    
    # Register the handler
    run_context.register_node_input_handler(folder_analyzer_input_handler)
    
    # Create a runner
    runner = FlowRunner(code_assistant, run_context)
    
    # Run in isolated execution context
    async with IsolatedExecution(run_context) as execution:
        # Set the user request as input for the AI model node
        from dhenara.agent.dsl.inbuilt.flow_nodes.defs.types import AIModelNodeInput
        run_context.register_node_static_input(
            "code_generator",
            AIModelNodeInput(prompt_variables={"user_request": user_request})
        )
        
        # Execute the flow
        result = await execution.run(runner)
        return result

# Run the agent
if __name__ == "__main__":
    user_request = "Create a function that calculates the Fibonacci sequence"
    asyncio.run(run_agent(user_request))
```

## Multi-Agent Collaboration Pattern

For more complex applications, you can create multiple agents that collaborate:

```python
# Create a planning agent
planner = FlowDefinition(root_id="planner")
# Add nodes to the planner...

# Create an execution agent
executor = FlowDefinition(root_id="executor")
# Add nodes to the executor...

# Create a coordinating agent
coordinator = AgentDefinition(root_id="coordinator")
coordinator.flow("planning", planner)
coordinator.flow("execution", executor)

# Define the coordination logic
coordinator.sequence(["planning", "execution"])

# Add conditionals for more complex logic
coordinator.condition("execution", lambda ctx: ctx.get_result("planning").success)
```

## Best Practices

### 1. Input and Output Management

Define clear input and output types for nodes:

```python
from pydantic import BaseModel
from dhenara.agent.dsl.base import NodeInput, NodeOutput

class CodeGenerationInput(NodeInput):
    repo_analysis: str
    user_request: str
    language: str = "python"

class CodeGenerationOutput(NodeOutput):
    code: str
    file_path: str
    explanation: str
```

### 2. Error Handling

Implement proper error handling in your flows:

```python
# Add error handling node
flow.node(
    "error_handler",
    AIModelNode(
        # Configuration...
    )
)

# Connect with error handling
flow.connect("main_node", "success_node", on_success=True)
flow.connect("main_node", "error_handler", on_error=True)
```

### 3. Reusable Components

Create reusable flow components:

```python
def create_code_analysis_flow(language: str) -> FlowDefinition:
    flow = FlowDefinition()
    # Add language-specific nodes...
    return flow

# Use in multiple places
python_analyzer = create_code_analysis_flow("python")
java_analyzer = create_code_analysis_flow("java")
```

### 4. Testing Strategies

Test your agents with different approaches:

```python
# Unit testing for individual nodes
async def test_code_generator_node():
    node = AIModelNode(# Configuration...)
    result = await node.execute(
        node_id="test_node",
        execution_context=mock_context,
        node_input=mock_input
    )
    assert result.output.code is not None

# Integration testing for flows
async def test_code_assistant_flow():
    run_context = RunContext(# Configuration...)
    runner = FlowRunner(code_assistant, run_context)
    result = await runner.run()
    assert result.status == "completed"
```

### 5. Resource Management

Implement resource pooling for efficient model usage:

```python
# Define a model pool
model_pool = ["claude-3-5-sonnet", "gpt-4-turbo", "claude-3-5-haiku"]

# Use it in nodes
ai_node = AIModelNode(
    resources=ResourceConfigItem.with_models(model_pool),
    # The system will try models in order until one succeeds
)
```

## Common Pitfalls

1. **Large Inputs/Outputs**: Be careful with large data - use chunking or summarization
2. **Event Handler Leaks**: Ensure event handlers don't persist beyond their needed lifetime
3. **Resource Exhaustion**: Implement rate limiting and fallbacks for API calls
4. **Non-Deterministic Flows**: Seed random factors when reproducibility is important
5. **Incomplete Error Handling**: Always handle errors at both node and flow levels

## Deployment Considerations

1. **Environment Configuration**: Use resource profiles for different environments
2. **Observability Setup**: Ensure proper logging and tracing in production
3. **Scaling**: Consider how multiple agent instances will interact
4. **Security**: Properly manage credentials and sensitive inputs/outputs
5. **Monitoring**: Implement health checks and monitoring for production agents

By following these patterns and practices, you can build robust, maintainable agent applications with DAD that solve real-world problems effectively.
